# Model Registry + Training/Inference Configuration

This note explains the **model registry flow** added to AgroVision and what to change when you:
- train a new model,
- add a new architecture,
- or switch the model used for inference.

It references:
- `agrovision_core/src/agrovision_core/train/train.py`
- `agrovision_core/src/agrovision_core/models/registry.py`
- `agrovision_core/src/agrovision_core/models/unet_baseline.py`
- `config/config.yaml`

---

## Why we changed this

Previously, training and inference were hard-coded to `UNet` in code. That makes it easy to break when a new model is added. The registry introduces a stable interface:

- **Models register themselves** by name.
- **Training/inference builds by name** (from config or checkpoint metadata).
- **Checkpoints carry metadata** so inference can rebuild the exact architecture without code changes.

This keeps the backend stable and makes adding a new model a small, predictable change.

---

## The registry pattern (overview)

- `registry.py` holds a global `MODEL_REGISTRY` and a `register_model` decorator.
- Each model file registers itself with `@register_model("model_name")`.
- `ensure_models_loaded()` autoloads all modules under `agrovision_core.models` so the registry is populated.
- Training/inference call `build_model(...)` to instantiate by name.

---

## Files and responsibilities

### 1) `agrovision_core/src/agrovision_core/models/registry.py`
- **register_model(name)**: decorator to register models by name.
- **build_model(name, in_channels, num_classes, model_cfg)**: instantiate the registered model.
- **ensure_models_loaded()**: import all modules so decorators run.

This file is the single source of truth for supported model names.

### 2) `agrovision_core/src/agrovision_core/models/unet_baseline.py`
- `UNet` is registered with:
  ```python
  @register_model("unet_baseline")
  class UNet(nn.Module):
      ...
  ```

Any new model should follow the same pattern.

### 3) `agrovision_core/src/agrovision_core/train/train.py`
- Calls `build_model(args.model, in_channels, num_classes, model_cfg)` from the registry.
- Saves model metadata in checkpoints:
  - `model_name`, `model_cfg`, `in_channels`, `num_classes`

That makes checkpoints self-describing for inference.

### 4) `config/config.yaml`
- Defines **model defaults** used for training/inference.
- Optional but recommended:
  ```yaml
  model:
    name: unet_baseline
    device: cuda
    num_classes: 14
    input_size: 256
    # model-specific params:
    base_channels: 64
    depth: 4
    dropout: 0.0
  ```

If `model.name` is omitted, the code defaults to `unet_baseline`.

---

## How to add a new model (architecture)

1) **Create the model class** (new file under `agrovision_core/models/`).
2) **Register it**:
   ```python
   from .registry import register_model

   @register_model("my_model")
   class MyModel(nn.Module):
       def __init__(self, in_channels: int, num_classes: int, **kwargs):
           ...
   ```
3) **Add any model-specific params** to `config.yaml` under `model:`.
4) **Train using the name**:
   ```bash
   python -m agrovision_core.train.train --model my_model
   ```

No changes required in inference or routing if the model is registered.

---

## How to train a new model

1) Set or confirm model config in `config.yaml`.
2) Run training:
   ```bash
   python -m agrovision_core.train.train --config config/config.yaml --model my_model
   ```
3) The checkpoint will include:
   - `model_name`
   - `model_cfg`
   - `in_channels`
   - `num_classes`

This is used by inference to rebuild the model correctly.

---

## How to use a new model for inference

1) Train it and get the checkpoint.
2) Update:
   ```yaml
   paths:
     production_model_path: outputs/models/<your_checkpoint>.pth
   model:
     name: my_model
   ```
3) Restart the backend.

Inference will read metadata from the checkpoint first, then fall back to `config.yaml`.

---

## Required constructor signature

All registered models must accept:
```python
__init__(self, in_channels: int, num_classes: int, **kwargs)
```

Why: the registry always passes `in_channels` and `num_classes`, plus extra config as kwargs.

---

## Common pitfalls

- **Model not registered**: you forgot `@register_model("name")` or the file isn’t imported.
- **Wrong constructor args**: model doesn’t accept `in_channels` / `num_classes`.
- **Missing config params**: model expects a param but it’s not in `config.yaml`.

---

## Minimal checklist for new models

- [ ] Add new file in `agrovision_core/models/`.
- [ ] Decorate class with `@register_model("your_name")`.
- [ ] Ensure `__init__(in_channels, num_classes, **kwargs)` exists.
- [ ] Add any required params to `config.yaml`.
- [ ] Train with `--model your_name`.
- [ ] Point `production_model_path` to the new checkpoint.
- [ ] Run a smoke test (update module path for your model):
  ```bash
  uv run python -m agrovision_core.models.unet_baseline
  ```

---

## Notes

- `ensure_models_loaded()` is called in training/inference so registry is populated without manual imports.
- Checkpoints remain backward compatible with older `state_dict`-only files.
